{
  "id": "mangaworld",
  "name": "MangaWorld",
  "description": "MangaWorld is a manga provider for MangaWorld. It mainly focuses on Italian mangas.",
  "manifestURI": "",
  "version": "1.0.0",
  "author": "kRYstall9",
  "type": "manga-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path='./manga-provider.d.ts' />\n/// <reference path='./doc.d.ts' />\n\nclass Provider {\n  private api = 'https://www.mangaworld.nz';\n\n  getSettings(): Settings {\n    return {\n      supportsMultiLanguage: false,\n      supportsMultiScanlator: false,\n    };\n  }\n\n  async search(opts: QueryOptions): Promise<SearchResult[]> {\n    let queryParam: string = opts.query;\n    queryParam = queryParam.toLowerCase();\n\n    const url = `${this.api}/archive?keyword=${encodeURIComponent(queryParam)}`;\n\n    if (url == null) {\n      return [];\n    }\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch search results: ${response.statusText}`);\n      }\n\n      const body = await response.text();\n      const doc: DocSelectionFunction = LoadDoc(body);\n\n      let mangas: SearchResult[] = await Promise.all(\n        doc('div.comics-grid>div.entry').map(async (index, element) => {\n          const title = element\n            .find('a.manga-title')\n            .first()\n            .attrs()['title'];\n          const thumbnailUrl = element.find('a.thumb img').first().attrs()['src'];\n          const mangaId = element\n            .find('a.thumb')\n            .first()\n            .attrs()\n          ['href'].split('manga/')[1];\n\n          let aniListDetails = await this.getAniListMangaDetails(queryParam);\n\n          let mangaDetails = {\n            id: mangaId,\n            title: title,\n            synonyms: aniListDetails.synonyms,\n            year: aniListDetails.year,\n            image: thumbnailUrl,\n          };\n\n          return mangaDetails;\n        })\n      );\n\n      let uniqueMangas = Array.from(\n        new Map(mangas.map((m) => [m.id, m])).values()\n      );\n      return uniqueMangas;\n    }\n    catch (e: any) {\n      console.error(e);\n      return [];\n    }\n  }\n\n  async findChapters(mangaId: string): Promise<ChapterDetails[]> {\n    console.info('kRYstall9 - mangaId: ' + mangaId);\n\n    const url = `${this.api}/manga/${mangaId}`;\n\n    try {\n      let response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch chapters: ${response.statusText}`);\n      }\n\n      let body = await response.text();\n      const doc: DocSelectionFunction = LoadDoc(body);\n\n      const chaptersWrapper = doc('div.chapters-wrapper');\n\n      const volumesContainer = chaptersWrapper.has('div.volume-element');\n\n      let finalChapters: ChapterDetails[] = [];\n\n      if (volumesContainer.html() != '') {\n        const volumes = chaptersWrapper\n          .children('div.volume-element')\n          .map((index: number, element: DocSelection) => {\n            return element.children('div.volume-chapters');\n          });\n\n        for (let volume of volumes) {\n          let chapters = volume.children('div').map((index, element) => {\n            let id = element\n              .find('a')\n              .first()\n              .attrs()\n            ['href'].split('manga/')[1]\n              .split('?')[0];\n            let url = element.find('a').first().attrs()['href'].split('?')[0];\n            let title = element.find('span').first().text();\n            let chapter = title.split(' ')[1];\n            let chapterIndex = this.getConvertedIndex(chapter);\n\n            let chapterDetails: ChapterDetails = {\n              id: id,\n              url: url,\n              title: title,\n              chapter: chapter,\n              index: chapterIndex,\n            };\n            return chapterDetails;\n          });\n          finalChapters.push(...chapters);\n        }\n      } else {\n        doc('div.chapters-wrapper>div.chapter').each((_, elem) => {\n          let id = elem\n            .find('a')\n            .first()\n            .attrs()\n          ['href'].split('manga/')[1]\n            .split('?')[0];\n          let url = elem.find('a').first().attrs()['href'].split('?')[0];\n          let title = elem.find('span.d-inline-block').text();\n          let chapter = `${title.split(' ')[1]}`;\n          let chapterIndex = this.getConvertedIndex(chapter);\n\n          let chapterDetails: ChapterDetails = {\n            id: id,\n            url: url,\n            title: title,\n            chapter: chapter,\n            index: chapterIndex,\n          };\n\n          finalChapters.push(chapterDetails);\n        });\n      }\n\n      finalChapters.reverse();\n      return finalChapters;\n    }\n    catch (e: any) {\n      console.error(e);\n      return []\n    }\n\n  }\n\n  async findChapterPages(chapterId: string): Promise<ChapterPage[]> {\n    const url = `${this.api}/manga/${chapterId}?style=list`;\n    const referer = url.split('/read')[0];\n\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch chapter pages: ${response.statusText}`);\n      }\n\n      const body = await response.text();\n      const doc: DocSelectionFunction = LoadDoc(body);\n\n      let pages: ChapterPage[] = [];\n      doc('div#page>img').each((index, element) => {\n        let obj: ChapterPage = {\n          url: element.attrs()['src'],\n          index: index,\n          headers: {\n            Referer: referer,\n          },\n        };\n        pages.push(obj);\n      });\n      return pages;\n    }\n    catch (e: any) {\n      console.error(e);\n      return []\n    }\n  }\n  async getAniListMangaDetails(query: string, id: number = 0) {\n    const aniListAPI = 'https://graphql.anilist.co';\n    let variables = {};\n    let aniListQuery = '';\n\n    if (id == 0) {\n      variables = {\n        search: query,\n      };\n      aniListQuery = this.getAniListQueryString('search');\n    } else {\n      variables = {\n        mediaId: id,\n      };\n      aniListQuery = this.getAniListQueryString('id');\n    }\n\n    let options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n      },\n      body: JSON.stringify({\n        query: aniListQuery,\n        variables: variables,\n      }),\n    };\n    let responseGraph = await fetch(aniListAPI, options);\n\n    if (!responseGraph.ok) {\n      throw new Error(\n        `Failed to fetch search results: ${responseGraph.statusText}`\n      );\n    }\n\n    let data: GraphQLResponse = await responseGraph.json();\n    let mangaYear = data.data.Media.startDate['year'];\n    let mangaSynonyms = data.data.Media.synonyms;\n\n    let mangaDetails: AniListMangaDetails = {\n      title: data.data.Media.title.english,\n      synonyms: mangaSynonyms ?? [],\n      year: mangaYear,\n    };\n\n    return mangaDetails;\n  }\n\n  getAniListQueryString(type: string): string {\n    let query = `query`;\n\n    switch (type) {\n      case 'id':\n        query += `($mediaId: Int) {\n              Media(id: $mediaId) {`;\n        break;\n      case 'search':\n        query += `($search: String) {\n              Media(search: $search) {`;\n        break;\n    }\n    query += `id\n        title {\n          romaji\n          english\n          native\n        }\n        startDate {\n          day\n          month\n          year\n        }\n        meanScore\n        synonyms\n        updatedAt\n        coverImage {\n          large\n        }\n      }\n      }`;\n    return query;\n  }\n\n  getConvertedIndex(mangaChapter: string): number {\n    let chapterNumber = mangaChapter.split('.');\n    return Number(chapterNumber[0]);\n  }\n}\n\ninterface MangaDetails {\n  id: string;\n  title: string;\n  synonyms?: string[];\n  year?: number;\n  image?: string;\n}\n\ninterface AniListMangaDetails {\n  title: string;\n  synonyms: string[];\n  year: number;\n}\n\ninterface GraphQLResponse {\n  data: {\n    Media: {\n      id: number;\n      title: {\n        romaji: string;\n        english: string;\n        native: string;\n      };\n      startDate: {\n        day: number;\n        month: number;\n        year: number;\n      };\n      meanScore: number;\n      synonyms: string[];\n      updatedAt: string;\n      coverImage: {\n        large: string;\n      };\n    };\n  };\n}\n"
}